% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%\usepackage{tikz}
%\usetikzlibrary{arrows}
\usepackage{verbatim}
%\usepackage{amsmath}
%\usepackage{amssymb}
%\usepackage{graphicx}
%\usepackage[all]{xy}
\usepackage{array}
\usepackage{enumitem}
%\usepackage{cite}
\usepackage{natbib}
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}
\usepackage[breaklinks=true]{hyperref}
\usepackage{breakcites}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\input{coq-listings}

\begin{document}
%
\title{Verifying TPM DevID Provisioning\thanks{This work is funded in part
    by the NSA Science of Security initiative contract
    \#H98230-18-D-0009 and Defense Advanced Research Project Agency
    contract \#HR0011-18-9-0001 and Honeywell FMT Purchase Order
    \#N000422909. The views and conclusions contained in this document
    are those of the authors and should not be interpreted as
    representing the official policies, either expressed or implied,
    of the U.S. Government.}}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Sarah Johnson \and
Perry Alexander}
%
\authorrunning{S. Johnson and P. Alexander.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Institute for Information Sciences \\ The
  University of Kansas \\ Lawrence, KS 66045 \\
  \email{\{sarahjohnson,palexand\}@ku.edu}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
  Provisioning of TPM-based secure device identifiers must be
  verified to ensure such identifiers are strongly bound to their
  associated devices.  Appraising attestation results without such
  assurances calls into question the integrity of trust decisions.  We
  developed and verified two models of TCG provisioning protocols
  ensuring that resulting secure identifiers were created in the
  presence of keys from which they derive their trust.  As a result we
  can be assured that device identifiers are verifiably bound to their
  associated devices.
% \begin{abstract}
%   A secure device identifier (DevID) is an identifier that is
%   cryptographically bound to a device. Trusted Platform Module (TPM)
%   keys are an ideal choice for implementation of these identifiers.
%   The specification ``TPM 2.0 Keys for Device Identity and
%   Attestation'' by the Trusted Computing Group (TCG) describes several
%   procedures for remotely proving a key to be resident in a specific
%   device's TPM and thereby satisfying the requirements for a
%   DevID. These procedures are carefully constructed protocols that are
%   intended to be performed by a trusted Certificate Authority (CA) in
%   communication with a certificate-requesting device and are designed
%   to maintain a cryptographic evidentiary chain linking a DevID to a
%   specific TPM. The TCG claims that each protocol provides certain
%   assurances; these assurances are the basis for the resulting
%   cryptographic evidentiary chain.  We aim to determine the
%   correctness of key certification protocols by abstractly modeling
%   and formally verifying their properties.

\keywords{Secure Device Identifiers \and TPM \and Verification.}
\end{abstract}
%
%
%
\section{Introduction}
Development and deployment of trusted systems requires strong device
identification~\citep{Martin:08:The-ten-page-in}. An entity should
have confidence that a remote device is the device it claims to be. An
ideal method for fulfilling this need uses cryptographic keys in the
Trusted Platform Module (TPM) as secure device identifiers
\citep{DevIDSpec-TCG}. A secure device identifier (DevID) is defined
as an identifier that is cryptographically bound to a device by a
trusted party~\citep{DevIDSpec-IEEE}.  As a secure Root of Trust for
Storage and Reporting~\citep{TPMSpec}, a TPM provides the necessary
protections for generating and storing DevIDs with suitable integrity
guarantees.

The Trusted Computing Group (TCG) describes protocols for assuring a
key to be resident in a specific device's
TPM~\citep{DevIDSpec-TCG}. These protocols are performed by a trusted
Certificate Authority (CA) in communication with a
certificate-requesting device and maintain a cryptographic evidentiary
chain linking a DevID to a specific TPM \citep{DevIDSpec-TCG}.  For
each provisioning procedure, the TCG outlines a protocol for the CA
and the certificate-requesting entity. Furthermore, the TCG claims
that each protocol provides certain assurances. These assurances are
the basis for the resulting cryptographic evidentiary chain.  Each
assurance manifests as an assertion regarding either TPM-residency,
key attributes, or previously-issued certificates.

Our work examines correctness of two key certification protocols: (i)
OEM Creation of an IAK Certificate based on an EK Certificate; and
(ii) Owner Creation of an LAK Certificate based on an IAK
Certificate. These DevID establishment protocols are essential for our
work in remote
attestation~\cite{Coker::Principles-of-R,petz2022innovations} where
device appraisal requires strong identification of an attestation
source. Specifically, that the signing key for attestation is bound to
the attestation manager responsible for attestation.  Formal
verification is required for integration into our formally
verified/synthesize attestation
environment\citep{petz2022innovations}.  Our contributions include:
(i) the design and implementation of an abstract formal model of
command execution; (ii) a formal analysis of two TCG-provided key
certification protocols; and (iii) the discovery of a potential
shortcoming of the IAK provisioning procedure and a recommendation for
its improvement.

\section{Related Work}
The Privacy CA protocol for the TPM 1.2 has been extensively studied
using various formal methods. The Privacy CA protocol was replaced by
the Direct Anonymous Attestation (DAA) scheme in the TPM 2.0. Both of
these protocols aim to accomplish the same fundamental purpose: allow
remote authentication of a device while maintaining its
anonymity. These protocols differ from the key certification protocols
analyzed in my work which aim to provide individual identification of
a device.  The work of~\citet{PrivacyCAAnalysis-Chen} analyzes the
Privacy CA protocol in the presence of an adversary. They suggest a
small modification to the protocol that enhances its security without
changing the existing functionality of the TPM 1.2. I similarly
suggest a small modification to the IAK provisioning procedure which
requires no change to the existing functionality of the TPM 2.0.  On
the other hand, the work of~\citet{PrivacyCAAnalysis-Hall,TPM12Model}
analyzes the Privacy CA protocol but does not consider any specific
adversary. Instead, they consider the functional correctness of the
protocol and specifically examine the protocol implementation to
ensure that it produces the results that it should.  My work has many
parallels to the works of~\citeauthor{PrivacyCAAnalysis-Hall}.  We
attempt to determine whether the implementations of certain key
certification protocols result in the assurances that they should.
Furthermore,~\citeauthor{PrivacyCAAnalysis-Hall} abstractly model a
large subset of the TPM 1.2 commands in the PVS specification
language. They model TPM command execution as a transition system over
an abstract system state. We implement this same technique in my own
work but over a small subset of TPM 2.0 commands as well as several
non-TPM commands.

The works of~\citet{DAAAnalysis-Whit} and~\citet{DAAAnalysis-Wes}
thoroughly study the DAA scheme of the TPM 2.0. Collectively, they
develop a symbolic model, a C++ implementation, and a
formally-verified fix of the scheme.  Many other works use formal
methods to examine other aspects of both the TPM 1.2
\citep{AuthAnalysis,PCRAnalysis} and 2.0
\citep{EAAnalysis,HMACAnalysis}.  These aspects include
authentication, platform configuration registers (PCRs), enhanced
authorization (EA), and hash-based message authentication code (HMAC)
mechanisms. They utilize tools and techniques such as SAPIC, Tamarin,
stateful applied pi calculus, amongst others.
%
%
%
\section{Background}
\subsection{TPM 2.0}
A Trusted Platform Module (TPM) is a microcontroller that complies
with the ISO/IEC 11889:2015 international standard.  The TPM and its
specification were designed by the Trusted Computing Group (TCG) to
act as a hardware root-of-trust for PC system security. To this end,
TPMs have capabilities for secure generation of keys, algorithm
agility, secure storage of keys, enhanced authorization, measurement
storage and reporting, device identification, and NVRAM
storage~\citep{{PracticalGuide}}.

Attestation is high-integrity reporting of system measurements stored
in platform configuration registers (PCRs).  PCRs store a composite of
a measurement chain in a way that guarantees integrity. Rather than
being set like a traditional register, a PCR is extended by
concatenating a new hash to the current PCR value, hashing and storing
the result.  Thus, a PCR captures both measurement value and order
over an arbitrarily long measurement sequence.  An attestation is a
PCR composite signed to guarantee integrity and authenticity.  To tie
attestation data to a specific device, the signing key must be
cryptographically bound to that device making the key a secure device
identifier.

A TPM key is an asymmetric key that can only be used by the creating
TPM.  Primary TPM keys created with \verb|TPM2_CreatePrimary| are
maintained internally by the TPM as roots for chaining key ownership.
Primary keys are shielded and unavailable outside the TPM.  Ordinary
TPM keys created with \verb|TPM2_Create| and are wrapped by a parent
TPM key and can be stored outside the TPM.  The wrapping operation
encrypts the ordinary TPM key's private key with the parent's public
key and includes a PCR composite. The public key remains clear and can
be used for encryption and signature checking.  However, decryption
and signing is impossible if the parent key is not installed in the
TPM to decrypt the private key.  Wrapping creates an ownership chain
from ordinary keys to a primary key that cannot be removed from the
TPM, thus binding keys in the chain to the TPM.

Keys have attributes that define their purpose in TPM, restricting how
they are used. Attributes include \verb|FixedTPM| to control
duplication, \verb|Sign| and \verb|Decrypt| to indicate use as a
signing or encryption key.  An additional \verb|Restricted| attribute
further restricts signing and decryption keys.  A restricted signing
key may only sign a PCR digest produced by the TPM during attestation
and to prove that a new key is loaded on the same TPM as itself during
certification.  A valid signature proves that quoted PCR values or new
key are from the same TPM as the original key.  If the signing key is
bound to the a TPM, then the PCR values or new key are also bound to
the same TPM.

A restricted decryption key is called a storage key. Only storage keys
can be used as parents to create or load child objects or to activate
credentials~\citep{PracticalGuide}. The EK is initialized by the TPM
manufacturer and stored in a shielded location on the TPM. The
corresponding EK certificate is the root certificate for chains of
IAKs and LAKs and thus plays a significant role in the creation of
DevID certificates.

\subsection{Secure Device Identifier}
A secure device identifier (DevID) is an identifier that is
cryptographically bound to a device \citep{DevIDSpec-IEEE}. A DevID
must not be transferable from one device to another and must be stored
in a way that protects it from modification. The binding of TPM keys
to their associated TPM makes them an ideal choice for DevIDs.

Binding a TPM key to a specific device instance is captured by a DevID
certificate. Certificates are chained from a trusted root certificate
to extend trust to new keys. To know when and by whom DevIDs are
created, it is useful to examine the creation and distribution of
TPM-containing devices resulting certificates and trust relationships
shown in Figure~\ref{fig:cert_rel}:



% \begin{enumerate}
% \item\label{ite:idTPM} Manufacturers produce TPMs provisioned with an
%   EK certificate binding the EK to a specific TPM. TPMs and EK
%   certificates are then distributed to Original Equipment
%   Manufacturers (OEMs) and represent roots-of-trust.
% \item\label{ite:idDevIni} OEMs produce devices with TPMs provisioned
%   with one or more IDevID certificates that bind an IDevID key to a
%   device. Devices are then distributed to end users (Owners).
% \item\label{ite:idDevLoc} Owners may optionally provision their TPMs
%   with one or more LDevID certificates that bind LDevID keys to their
%   device.
% \end{enumerate} 

% \noindent Modeling and verifying device identification provisioning
% using CAs in \ref{ite:idDevIni} and \ref{ite:idDevLoc} is the subject
% of this work.

\begin{itemize}[itemsep=0pt,parsep=0pt,partopsep=0pt]
\item \textsf{TPM Manufacturer}: Manufacturers produce TPMs provisioned with an
  EK certificate binding the EK to a specific TPM.
  \begin{itemize}[itemsep=0pt,parsep=0pt,partopsep=0pt]
  \item The EK is initialized in an immutable, hidden location
  \item The EK certificate is generated and signed by the TPM
    Manufacturer's CA binding the EK to the TPM
  \end{itemize}
\item \textsf{OEM}: OEMs produce devices with TPMs provisioned with
  one or more IDevID certificates that bind an IDevID key to a device.
  \begin{itemize}[itemsep=0pt,parsep=0pt,partopsep=0pt]
  \item \textsf{A}: The IAK is created and verified by the OEM's CA to
    have correct key properties and to be loaded on the same TPM
    as the EK.
  \item \textsf{B}: The IDevID is created and verified by the OEM's CA
    to have the correct key properties and to be loaded on the same
    TPM as the IAK.
  \item \textsf{CA Signing}: The IAK certificate and IDevID
    certificate are signed by the OEM's CA binding the IAK and IDevID
    to this specific device.
  \end{itemize}
\item \textsf{Owner}: Owners may optionally provision their TPMs with
  one or more LDevID certificates that bind LDevID keys to their
  specific device.
  \begin{itemize}[itemsep=0pt,parsep=0pt,partopsep=0pt]
  \item \textsf{C}: The LAK is created and verified by the Owner's CA
    to have the correct key properties and to be loaded on the same
    TPM as the IAK.
  \item \textsf{D}: The LDevID is created and verified by the Owner's
    CA to have the correct key properties and to be loaded on the same
    TPM as the LAK.
  \item \textsf{CA Signing}: The LAK certificate and LDevID
    certificate are signed by the Owner's CA binding the LAK and
    LDevID to this specific device.
  \end{itemize}
\end{itemize}

\begin{figure}[htbp]
  \begin{centering}
  \includegraphics[width=\linewidth]{figures/certRelationships.png}
  \par\end{centering}
  \caption{Key and Certificate Relationships \citep{DevIDSpec-TCG}}
  \label{fig:cert_rel}
\end{figure}

Trust for new DevID certificate creation is inherited from an existing
trusted certificate forming a chain-of-trust from a DevID back to a
trust anchor~\citep{DevIDSpec-TCG}. Since IAK certificates are tied to
the EK and provide definitive evidence that a key belongs to a
specific device, an IAK certificate acts as this trust anchor and is
the root node in a chain of certificates. In issuing an IAK
certificate, the OEM's CA makes an assertion that is a primary
security dependency for the provisioning of all future DevIDs.

%% What are "correct key properties?"

\section{Protocol Execution}

\subsection{Keys and Certificates}

Our Coq model inductively defines a \verb|pubKey| and \verb|privKey|
type for public keys and private keys respectively. A key of either
type requires a unique identifier and a sequence of boolean values
describing whether a particular attribute is set or not set. A key
pair consists of a \verb|pubKey| and a \verb|privKey| with the same
identifier and attributes.

\begin{lstlisting}[language=Coq]
Inductive pubKey : Type :=
| Public : keyIdType -> Restricted -> Sign -> Decrypt -> FixedTPM -> pubKey.

Inductive privKey : Type :=
| Private : keyIdType -> Restricted -> Sign -> Decrypt -> FixedTPM -> privKey.
\end{lstlisting}

Certificates are defined by the inductive type \verb|signedCert|
consisting of a public key, an identifier, and a private key. The
identifier represents the certificate's Subject field and may include
information describing either the TPM or the device. The private key
parameter denotes the key that performed the signature over the
certificate.

\begin{lstlisting}[language=Coq]
Inductive identifier : Type :=
| TPM_info : tpmInfoType -> identifier
| Device_info : deviceInfoType -> identifier.

Inductive signedCert : Type :=
| Cert : pubKey -> identifier -> privKey -> signedCert.
\end{lstlisting}

\subsection{Commands}

The protocols used to create DevID certificates require performing
TPM, TSS and non-TPM commands. A command may rely on a variety of
parameters such as keys, nonces, certificates, as well as messages
that define structures an entity may use or produce. The
\verb|message| type is an abstract representation of these structures
in Figure~\ref{fig:message-model}.

\begin{figure}[hbtp]
\begin{lstlisting}[language=Coq]
Inductive message : Type :=
| publicKey : pubKey -> message
| privateKey : privKey -> message
| hash : message -> message
| signature : message -> privKey -> message
| TPM2B_Attest : pubKey -> message
| encryptedCredential : message -> randType -> pubKey -> message
| randomNum : randType -> message
| TCG_CSR_IDevID : identifier -> signedCert -> pubKey -> message
| TCG_CSR_LDevID : message -> signedCert -> message
| signedCertificate : signedCert -> message
| pair : message -> message -> message.
\end{lstlisting}
\caption{Message Model}
\label{fig:message-model}
\end{figure}

An entity may derive additional messages from a collection of known
messages. For example, given a message of the form
\verb|signature m k|, the message \verb|m| may be deduced. Whereas
given a message in the form \verb|encryptedCredential n g k|, no
messages may be deduced. Message inference is modeled in two
equivalent ways: (i) a recursive function \verb|inferFrom|; and (ii)
an inductive proposition \verb|inferrable|.  Additional messages may
be derived from signed messages, \verb|TPM2B_Attest| structures,
certificate signing requests (CSRs), certificates, and message
pairs. Other messages either contain no additional information or
information is concealed.

Command execution is defined as an inductive proposition relating an
current state pair, a command, and a next state pair defining a
labeled transition system. We define a labeled transition system in
the canonical fashion as a triple $(S,L,\rightarrow)$ where $S$ is a
set of states, $L$ is a set of labels, and
$\rightarrow \subseteq S \times L \times S$ is a labeled transition
relation. In this case, $S$ is the set of \verb|tpm_state * state|
pairs; $L$ is the set of \verb|command| values; and $\rightarrow$ is
the \verb|execute| relation.

% \begin{figure}[h]
% \begin{lstlisting}[language=Coq]
% Inductive execute : tpm_state * state -> command -> tpm_state * state -> Prop
% \end{lstlisting}
% \caption{Type Signature of Execute Relation}
% \end{figure}

\verb|tpm_state| and \verb|state| are lists of messages. The
\verb|tpm_state| type contains messages that a restricted signing key
may operate on. Such messages may be in one of two forms: (i) objects
constructed from TPM-internal data such as private keys and PCRs; or
(ii) digests produced by signature hash operations.  The \verb|state|
type contains messages visible to the system.

% Each \verb|command| constructor corresponds with one constructor in the
% \verb|execute| relation with the exception of \verb|TPM2_Sign| that
% corresponds with two. Each constructor possesses its own distinctive
% conditions that must be met for execution to succeed. These conditions
% are manifested in several ways: constructors pattern match on the
% command's inputs, some inputs must be in the current, and the results
% must be in the next state.

\begin{figure}[hbtp]
  \begin{footnotesize}
\begin{lstlisting}[language=Coq]
Inductive command : Type :=
| TPM2_Hash : message -> command
| CheckHash : message -> message -> command
| TPM2_Sign : message -> privKey -> command
| TPM2_Certify : pubKey -> privKey -> command
| CheckSig : message -> pubKey -> command
| TPM2_MakeCredential : message -> randType -> pubKey -> command
| TPM2_ActivateCredential : message -> privKey -> privKey -> command
| MakeCSR_IDevID : identifier -> signedCert -> pubKey -> command
| MakeCSR_LDevID : message -> signedCert -> command
| CheckCert : signedCert -> pubKey -> command
| CheckAttributes : pubKey -> Restricted -> Sign -> Decrypt -> FixedTPM -> command
| MakePair : message -> message -> command.
\end{lstlisting}
\end{footnotesize}
\caption{Command data structure.}
\label{fig:command-model}
\end{figure}

The \verb|TPM2_Hash| command performs a cryptographic hash operation
on a piece of data. This data may be any message that is known to the
entity performing the command \verb|state|. The result of the
operation is abstractly defined using the opaque \verb|hash|
constructor and is stored in both the next \verb|tpm_state| and
\verb|state|.  The \verb|CheckHash| command verifies
that the contents of a hash digest match a particular plaintext
message. Both the hash digest and the plaintext message must be
contained in the current \verb|state|.

The \verb|TPM2_Sign| command generates a signature over a message
using the specified private key.  To succeed the key must have the
\verb|Sign| attribute set and the key must be present in
\verb|tpm_state|. Execution then differs based on the status of the
private key's \verb|Restricted| attribute. If the key does not have
the \verb|Restricted| attribute set the message must simply be in
\verb|state|. If the key does have the \verb|Restricted| attribute
set, the message must be in the current \verb|tpm_state|.

The \verb|TPM2_Certify| command is proof that an object is loaded in
the TPM by producing a signed \verb|TPM2B_Attest| structure. The
command requires two inputs: (i) a public key to be certified; and
(ii) a private key to sign the attestation structure. The private key
must have the \verb|Sign| attribute set and must be loaded. To
execute, the TPM verifies the public key parameter's inverse is also
loaded.

Messages produced by the \verb|TPM2_Sign| and \verb|TPM2_Certify|
commands are defined using the \verb|signature| constructor. A
signature may be verified against a public key using the
\verb|CheckSig| command.

The \verb|TPM2_MakeCredential| command is used when a remote entity,
desires to affirm that some private key is loaded on the same TPM as a
particular EK. This command produces a message with the
\verb|encryptedCredential| constructor and requires three inputs: the
cryptographic name of a key to be credentialed; a secret; and a public
EK. The cryptographic name of a key is produced by hashing its public
area with its associated hash algorithm and prepending the Algorithm
ID of the hashing algorithm.

The \verb|TPM2_ActivateCredential| command is used by the recipient of
an encrypted credential blob to release its secret.  The secret
contained in an encrypted credential blob is only released if the
credentialed key is loaded on the same TPM as the EK.  When executing
the \verb|TPM2_ActivateCredential| command, the TPM first decrypts the
blob with the EK then verifies that the private key corresponding with
the name field is also loaded. The secret is only released if both
steps succeed. The secret value may then be returned to the remote CA
so that they may validate the result.

The \verb|MakeCSR_IDevID| command produces a \verb|TCG_CSR_IDevID|
structure.  A \verb|TCG_CSR_IDevID| is a certificate signing request
(CSR) that contains the data required to couple an IAK to a
TPM-containing device.  In particular, this structure is used any time
a provisioning procedure uses the EK certificate.  The
\verb|MakeCSR_LDevID| command is similar except that it produces a
\verb|TCG_CSR_LDevID| structure that includes the certification
information for an LAK or LDevID.

The \verb|CheckCert| command verifies a signature over a certificate
against a public key. One should check an EK certificate against the
public key of the TPM Manufacturer's CA, an IAK or IDevID certificate
against the public key of the OEM's CA, and an LAK or LDevID
certificate against the public key of the Owner's CA.  The
\verb|CheckAttributes| command verifies a public key has all provided
attributes.  In order to check the attributes, one must have have
knowledge of that key. The key need not be loaded on a TPM since this
command is typically used to check the attributes of some external
entity's key.

\subsection{Protocols}

Commands are sequenced linearly by the \verb|sequence| type which is
identical in structure to the Coq type \verb|list|. Sequential command
execution is defined as an inductive proposition relating an current
state pair, a command sequence, and a next state pair. Sequential
execution is done by first executing the command at the head of the
list using the single command execution relation \verb|execute|
followed by executing the sequence at the tail of the list using the
sequential execution relation \verb|seq_execute|. The next state pair
produced by executing the single command is used as the current state
pair for the subsequent sequence. This recursive structure allows for
the convenient use of induction in many proofs.

\begin{figure}[hbtp]
\begin{lstlisting}[language=Coq]
Inductive sequence : Type :=
| Sequence : command -> sequence -> sequence
| Done : sequence.

Infix ";;" := Sequence (at level 60, right associativity).

Inductive seq_execute : tpm_state * state -> sequence -> tpm_state * state -> Prop :=
| SE_Seq : forall ini mid fin c s,
    execute ini c mid ->
    seq_execute mid s fin ->
    seq_execute ini (Sequence c s) fin
| SE_Done : forall ini,
    seq_execute ini Done ini.
\end{lstlisting}
\caption{Command Sequence Model}
\label{fig:command-sequence-model}
\end{figure}

We prove two intermediate properties of sequential execution. First,
sequential execution is deterministic. Given an initial state pair and
a command sequence, there is at most one final state pair that
satisfies the \verb|seq_execute| relation implying that command
sequence execution is a partial function. Second, sequential execution
is an expansion. Given a current state pair, command sequence, and
initial state pair, the initial state is always a subset of the final
state implying that command sequence execution is monotonic.

% \begin{figure}[hbtp]
%   \begin{lstlisting}[language=Coq]
%   Theorem seq_exec_deterministic : forall ini s fin1 fin2,
%     seq_execute ini s fin1 ->
%     seq_execute ini s fin2 ->
%     fin1 = fin2.
  
%   Theorem seq_exec_expansion : forall iniTPM ini s finTPM fin,
%     seq_execute (iniTPM,ini) s (finTPM,fin) ->
%     (iniTPM \subsetOf finTPM) /\ (ini \subsetOf fin).
%   \end{lstlisting}
%   \caption{Properties of Sequential Execution}
%   \label{fig:sequential-execution-properties}
%   \end{figure}

% For two commands to match, not only must the commands itself match but
% all of their inputs as well. To precisely describe this situation,
% this function utilizes the decidable equality property over the
% \verb|command| type. This requires declaring and proving that the
% \verb|command| type and all of the types it relies on (e.g.,
% \verb|message|, \verb|pubKey|, \verb|signedCert|) are members of the
% \verb|DecEq| class. These proofs may be conveniently automated.
%
%
%
\section{Identity Provisioning}

To mantain a cryptographic evidentiary chain linking a DevID to a
specific TPM and device, the CA should follow certain provisioning
procedures. The TCG describes several such procedures in
\citet{DevIDSpec-TCG}.  We consider two procedures in detail: OEM
creation of an IAK certificate based on an EK certificate and Owner
creation of an LAK certificate based on an IAK certificate.  For each
protocol, the specification outlines steps for the CA and the
certificate-requesting entity.  The specification claims that each
protocol provides certain assurances.  Each assurance manifests as an
assertion regarding either TPM-residency, key attributes, or
previously-issued certificates and provides the basis for the
resulting cryptographic evidentiary chain formed by a chain of
certificates. Therefore, it is important to verify that each protocol
guarantees its associated assurances.

When verifying these goals, we consider two scenarios: (i) the
certificate-requesting entity and the CA are both trusted to execute
their steps correctly; and (ii) only the CA is trusted to execute its
steps correctly.  Because trust for creation of a new certificate is
rooted in an existing certificate, these scenarios include the
presupposition that previously-issued certificates imply the assurance
from their provisioning protocols.

\subsection{Owner Creation of LAK Certificate based on IAK Certificate}

The TCG's specification claims that the procedure in
Figure~\ref{fig:lak-certificate-creation} provides
these assurances: (A) the LAK has good attributes; and (B) the LAK is
loaded on the same TPM as the IAK. These assurances correspond exactly
with the Chain of Trust line C in Figure \ref{fig:cert_rel}.

\begin{figure}[hpbt]
\begin{enumerate}[itemsep=0pt,parsep=0pt,partopsep=0pt]
  \setcounter{enumi}{-1}
  \item The Owner creates and loads the LAK
  \item The Owner certifies the LAK with the IAK
  \item The Owner builds the CSR% containing:
  % \begin{enumerate}[topsep=0pt, itemsep=0pt,parsep=0pt,partopsep=0pt]
  %   \item The signed \verb|TPM2B_Attest| structure
  %   \item The IAK certificate
  % \end{enumerate}
  \item The Owner takes a signature hash of the CSR
  \item The Owner signs the resulting hash digest with the LAK
  \item The Owner sends the CSR paired with the signed hash to the CA
  \item The CA verifies the recieved data% by checking:
  % \begin{enumerate}[topsep=0pt, itemsep=0pt,parsep=0pt,partopsep=0pt]
  %   \item The hash digest against the CSR
  %   \item The signature on the hash digest with the public LAK
  %   \item The signature on the \verb|TPM2B_Attest| structure with the public IAK
  %   \item The signature on the IAK certificate with the public key of the OEM's CA
  %   \item The attributes of the LAK
  % \end{enumerate}
  \item If all of the checks succeed, the CA issues the LAK certificate to the Owner
  \end{enumerate}
  \caption{LAK Certificate Creation}
  \label{fig:lak-certificate-creation}
\end{figure}

Modeling this protocol begins by defining parameters for the Owner and
CA. These parameters correspond with the elements required by the
Owner and the CA \emph{prior} to performing their respective parts of
the procedure.  The Owner have its LAK, IAK, and IAK certificate, and
the CA must have its own key and the public key of the OEM's CA. The
parameters only explicitly include the public key values of those
listed keys pairs. Private key values are represented in the model by
taking the inverse of the corresponding public key value. Private key
values are stored in the \verb|privLAK|, \verb|privIAK|, and
\verb|privCA| variables. To enforce the randomness of cryptographic
keys, all key parameters specified to be pairwise distinct.

% \begin{figure}[hbtp]
% \begin{lstlisting}[language=Coq]
% (* Owner parameters *)
% Parameter pubLAK : pubKey.
% Parameter pubIAK : pubKey.
% Parameter certIAK : signedCert.

% (* CA parameters *)
% Parameter pubCA : pubKey.
% Parameter pubOEM : pubKey.

% (* All keys are pairwise distinct *)
% Axiom keys_distinct :
%   pubLAK <> pubIAK /\
%   pubLAK <> pubCA /\
%   pubLAK <> pubOEM /\
%   pubIAK <> pubCA /\
%   pubIAK <> pubOEM /\
%   pubCA <> pubOEM.
% \end{lstlisting}
% \caption{Parameters of LAK Provisioning Procedure}
% \end{figure}

The certificate generation procedure is modeled as the composition of
two parts: the Owner's steps (i.e., Steps 0-5) followed by the CA's
steps (i.e., Steps 6-7).  Each part of the procedure may be modeled
using the parameters for initial values and the sequential command
construction defined previously.

\begin{figure}[hpbt]
\begin{lstlisting}[language=Coq]
Definition steps1to5_Owner : sequence :=
TPM2_Certify pubLAK privIAK
;; MakeCSR_LDevID (signature (TPM2B_Attest pubLAK) privIAK) certIAK
;; TPM2_Hash (TCG_CSR_LDevID (signature (TPM2B_Attest pubLAK) privIAK) certIAK)
;; TPM2_Sign 
    (hash (TCG_CSR_LDevID (signature (TPM2B_Attest pubLAK) privIAK) certIAK))
    privLAK
;; MakePair 
    (TCG_CSR_LDevID (signature (TPM2B_Attest pubLAK) privIAK) certIAK) 
    (signature
      (hash
        (TCG_CSR_LDevID
          (signature (TPM2B_Attest pubLAK) privIAK) certIAK)) privLAK)
;; Done. 
\end{lstlisting}
\caption{Owner's LAK Provisioning Protocol}
\label{fig:lak_model_Owner}
\end{figure}

We construct an object of \verb|sequence| type for the Owner and an
object of function type for the CA. Constructing the Owner's steps is
straightforward. Since this model disallows the arbitrary creation of
keys, Step 0 is assumed to have been performed prior; the results of
Step 0 are in fact already encapsulated in the \verb|pubLAK| parameter
and \verb|privLAK| variable. Then each remaining step of the Owner
corresponds with exactly one command in the model, namely
\verb|TPM2_Certify| for Step 1, \verb|MakeCSR_LDevID| for Step 2,
\verb|TPM2_Hash| for Step 3, \verb|TPM2_Sign| for Step 4, and
\verb|MakePair| for Step 5. 

Constructing the CA's steps is more complex as it relies on the
certification request produced by the Owner's steps. First, the CA
waits to receive a certification request from the Owner (see the
\verb|msg| input). The request must be in a specific format to be
considered valid. The CA then executes Step 6 of the procedure defined
by the sequence within \verb|seq_execute|. If execution succeeds, the
CA issues the LAK certificate to the Owner.  The model includes
several additional parameters and criteria to serve as a method for
referencing elements of the certification request within proof
statements.

\begin{figure}[hpbt]
\begin{lstlisting}[language=Coq]
Definition steps_CA (msg : message) (iak lak : pubKey) (cert : signedCert) : Prop :=
  match msg with
  | (pair (TCG_CSR_LDevID (signature (TPM2B_Attest k) k0') (Cert k0 id k_ca'))
          (signature m k')) =>
       iak = k0 /\ lak = k /\ cert = (Cert k0 id k_ca') /\
       seq_execute (iniTPM_CA, inferFrom msg ++ ini_CA)
         CheckHash m
           (TCG_CSR_LDevID (signature (TPM2B_Attest k) k0') (Cert k0 id k_ca'))
           ;; CheckSig (signature m k') k
           ;; CheckSig (signature (TPM2B_Attest k) k0') k0
           ;; CheckCert (Cert k0 id k_ca') pubOEM
           ;; CheckAttributes k Restricting Signing NonDecrypting Fixing
           ;; Done)
           (iniTPM_CA, inferFrom msg ++ ini_CA)
  | _ => False
  end.
\end{lstlisting}
\caption{CA's LAK Provisioning Protocol}
\label{fig:lak_model_CA}
\end{figure}

Assurance A is proved using only the CA's function. The
\verb|CheckAttributes| command in the CA's function corresponds with
Step 6e of the provisioning procedure.  Note that the CA's function
binds the LAK to the variable \verb|k|. It follows that successful
execution of this command implies the LAK has all of the attributes
required to be an attestation key.

We now verify Assurance B under the conditions of scenario 1 where the
Owner and the CA are both trusted to execute their steps
correctly. Recall that this verification trusts that the
previously--performed IAK provisioning procedure guarantees its
associated assurances, specifically that the IAK has good attributes.

First, we examine the Owner's steps and associated requirements. These
requirements can be quantitatively described by a minimal initial
state pair. Given a sequence, a minimal initial state pair is defined
as the smallest \verb|tpm_state| and \verb|state| that allows for
successful execution of the sequence. The proof statement describing
this property is constructed by two parts: (1) the minimal initial
state is a lower bound on the set of possible initial states and (2)
the minimal initial state is sufficient for successful execution.

We build a minimal initial state pair for \verb|steps1to5_Owner| using
the following intuition: (i) the private LAK and private IAK are
loaded on the same TPM because the LAK is certified by the IAK and
(ii) the IAK certificate is known to the Owner because it is included
in the CSR.  The proof of the lower bound property uses this
intuition.  The proof of the sufficiency property uses the
constructors of the \verb|execute| relation to demonstrate that a next
state pair exists that satisfies the \verb|seq_execute| relation for
the minimal initial state pair and \verb|steps1to5_Owner|. This proof
relies on two assumptions, the IAK has good attributes and that the CA
issues the LAK certificate.

\begin{figure}[hbtp]
\begin{lstlisting}[language=Coq]
  Definition iniTPM_Owner : tpm_state := [ privateKey privLAK
                                         ; privateKey privIAK ].

Definition ini_Owner : state := [ signedCertificate certIAK ].

Lemma ini_Owner_lowerBound : forall iniTPM ini fin,
  seq_execute (iniTPM, ini) steps1to5_Owner fin ->
  (iniTPM_Owner \subsetOf iniTPM) /\ (ini_Owner \subsetOf ini).

Lemma ini_Owner_sufficient : forall msg,
  attestationKey pubIAK ->
  steps_CA msg pubIAK pubLAK certIAK ->
  exists fin, seq_execute (iniTPM_Owner, ini_Owner) steps1to5_Owner fin.
\end{lstlisting}
\caption{Minimal Initial State of Owner}
\end{figure}

This analysis of the Owner's steps' requirements in the form of a
minimal initial state leads to the conclusion that the LAK and IAK
must be loaded on the same TPM for the Owner to execute its
steps. This conclusion is manifest in the \verb|iniTPM_Owner| variable
which contains both the private LAK and private IAK. In conclusion, we
have now confirmed that Assurance B is in fact guaranteed by the
protocol when we assume that both the Owner and the CA are trusted to
execute their steps correctly.

We now attempt verification of this same goal under the conditions of
scenario 2 where only the CA is trusted to execute its steps
correctly. This proof is troublesome and likely impossible if we make
no assumptions regarding the Owner.  Because the certification request
and its contents must have been produced by some entity, we consider
the Owner to be this entity.  Thus, we describe the Owner and its
characteristics as a series of assumptions: the Owner executes some
unknown sequence of commands \verb|s|, this sequence produces some
message \verb|msg| in the Owner's next \verb|state|, the Owner's
initial \verb|tpm_state| may only contain private keys, the Owner's
initial \verb|state| may only contain public keys and certificates,
and the CA executes its prescribed sequence on the message \verb|msg|.

\begin{figure}[hbtp]
\begin{lstlisting}[language=Coq]
Theorem lak_and_iak_in_TPM : forall s iniTPM ini finTPM fin msg iak lak cert,
  seq_execute (iniTPM, ini) s (finTPM, fin) -> 
  In msg fin ->
  (forall m', needsGeneratedTPM m' -> ~ In m' iniTPM) ->
  (forall m', needsGenerated m' -> ~ In m' ini) ->
  steps_CA msg iak lak cert ->
  In (privateKey (pubToPrivKey lak)) iniTPM
  /\ In (privateKey (pubToPrivKey iak)) iniTPM
\end{lstlisting}
\caption{Next Verification Goal for LAK Provisioning Procedure}
\label{fig:lak_goal}
\end{figure}

These assumptions are reasonable and do not corrupt the conditions
regarding the Owner's trustworthiness. The LAK, IAK, and IAK
certificates are universally quantified making no reference to the
Owner. The assumptions aim only to constrain the certification
request, \verb|msg|, and its contents to the Owner.  The restrictions
on the Owner's initial state pair are the main contributors to
enforcement of this constraint. Due to the nature of command
execution, the certification request and all of its contents must have
be produced by a command or contained in the initial state.
Therefore, restrictions placed on the initial state allow only those
messages that cannot be generated by a command sequence.  The
\verb|needsGeneratedTPM| function restricts the Owner's initial
\verb|tpm_state| to include only previously created private keys while
the \verb|needsGenerated| function restricts the Owner's initial
\verb|state| to include public keys as well as previously issued
certificates.  The subject of these certificates may be the Owner
itself or any other entity.  These restrictions prevent other
messages in the Owner state from being used to build the certification
request.

The next step is using this series of assumptions to learn more about
the Owner. We cannot directly prove the new LAK is loaded on the same
TPM as the IAK, but we can derive an important conclusion about the
command sequence the Owner executes. Specifically, the sequence
\verb|s| is a supersequence of the correct steps of the Owner.  We
define a cascading collection of recursive functions to determine
whether a given sequence of commands is a supersequence of
\verb|steps1to5_Owner|.  Using the current assumptions about Owner and
the CA we prove the Owner's unknown sequence \verb|s| satisfies
this property. The proof relies on the structure of the
certification request as it is required by the CA's steps. In order to
produce a message with this structure, specific commands must be
executed in a specific order.  The overall proof hinges on this
conclusion.

The next step is demonstrating the Owner must have executed
\verb|TPM2_Certify| on the public LAK and private IAK.  Recall our
conclusion that the LAK and IAK must be loaded on the same TPM if the
LAK is certified using the IAK. Using the previous conclusion it is
trivial to prove this command is contained within the Owner's sequence
\verb|s|.  We use the function \verb|command_in_sequence| to describe
this scenario.  We prove one last set of intermediate lemmas that show
that the LAK and IAK must be loaded on the same TPM for one to execute
any sequence that contains this command.  The composition of these
small proofs leads to our end goal shown in Figure
\ref{fig:lak_goal}. Due to extra parameters and criteria of the
\verb|steps_CA| function, the proof statement states that the inverse
of the key contained in the IAK certificate and the inverse of the key
contained in the new certificate are loaded on the same TPM.  This is
the assertion described by Assurance B.  Therefore, we have proven
that Assurance B is in fact guaranteed by the protocol assuming only
that the CA is trusted to execute its steps correctly.

This procedure uses the previously provisioned IAK to prove the
new LAK is loaded on the same TPM and thus contained in the device
identified by the IAK certificate. Therefore, when issuing the LAK
certificate, the CA should use the same device identifying information
as that from the IAK certificate's Subject field. To summarize,
Assurance A is guaranteed by the attribute check performed by the CA
and Assurance B is guaranteed by the IAK's \verb|Restricted| attribute
and the signed \verb|TPM2B_Attest| structure.

\subsection{OEM Creation of IAK Certificate based on EK Certificate}

The TCG's specification claims the procedure in
Figure~\ref{fig:iak-creation} guarantees three assurances: (A) the IAK
has good attributes; (B) the IAK is loaded on the same TPM as the EK;
and (C) the EK certificate is valid. These assurances correspond
exactly with the Proof of Residency line A in Figure
\ref{fig:cert_rel}.

\begin{figure}[hbtp]
\begin{enumerate}[itemsep=0pt,parsep=0pt,partopsep=0pt]
  \setcounter{enumi}{-1}
  \item The OEM creates and loads the IAK
  \item The OEM builds the CSR% containing:
  % \begin{enumerate}[topsep=0pt, itemsep=0pt,parsep=0pt,partopsep=0pt]
  %   \item Device identity information including the device model and serial
  %   number
  %   \item The EK certificate
  %   \item The IAK public area
  % \end{enumerate}
  \item The OEM takes a signature hash of the CSR
  \item The OEM signs the resulting hash digest with the IAK
  \item The OEM sends the CSR paired with the signed hash to the CA
  \item The CA verifies the received data% by checking:
  % \begin{enumerate}[topsep=0pt, itemsep=0pt,parsep=0pt,partopsep=0pt]
  %   \item The hash digest against the CSR
  %   \item The signature on the hash digest with the IAK public key
  %   \item The signature on the EK certificate with the public key of the TPM Manufacturer's CA
  %   \item The attributes of the IAK
  % \end{enumerate}
  \item If all of the checks succeed, the CA issues a challenge blob to the OEM% by:
  % \begin{enumerate}[topsep=0pt, itemsep=0pt,parsep=0pt,partopsep=0pt]
  %   \item Calculating the cryptographic name of the IAK
  %   \item Generating a nonce
  %   \item Building the encrypted credential structure
  % \end{enumerate}
  \item The OEM releases the secret nonce by decrypting the challenge
    blob and verifying the IAK name
  \item The CA checks the returned nonce against the one generated in Step 6b
  \item If the check succeeds, the CA issues the IAK certificate to the OEM
  \end{enumerate}
  \caption{IAK Certificate Creation by OEM}
  \label{fig:iak-creation}
\end{figure}

The procedure from Figure~\ref{fig:iak-creation} is similar to the one
described in the previous section. All steps except for Steps 1 and 6c
are included. We focus on the details that differ from the previous
verification process.

% Modeling this protocol begins by defining parameters for the OEM and
% CA. The OEM has its IAK, EK, EK certificate, and device identifying
% information and the CA has its own key, the public key of the TPM
% Manufacturer's CA, and a secret nonce.

% \begin{figure}[hbtp]
% \begin{lstlisting}[language=Coq]
% (* OEM parameters *)
% Parameter pubIAK : pubKey.
% Parameter pubEK : pubKey.
% Parameter certEK : signedCert.
% Parameter devInfo : deviceInfoType.

% (* CA parameters *)
% Parameter pubCA : pubKey.
% Parameter pubTM : pubKey.
% Parameter nonce : randType.
% \end{lstlisting}
% \caption{Parameters of IAK Provisioning Procedure}
% \end{figure}

The provisioning procedure may be viewed as the composition of four
parts: the OEM's initial steps (i.e., Steps 0-4) followed by the CA's
initial steps (i.e., Steps 5-6) followed by the OEM's final step
(i.e., Step 7) followed by the CA's final steps (i.e., Steps 8-9). The
initial steps of the OEM and the OEM's CA are constructed similarly to
the steps of the Owner and the Owner's CA respectively.  The OEM's
final step is naturally constructed as a simple function. First the
OEM waits to receive a challenge blob from the CA, then the OEM
executes Step 7. As a result, the CA's final steps are implicit in the
proof statements and do not require an explicit definition.

Proving Assurance A is trivial and proceeds identically to the
corresponding proof in the previous section. Proving Assurance C is
also quite similar. The command
\verb|CheckCert (Cert k0 id0 k_ca') pubTM| in the CA's function
corresponds with Step 5c of the provisioning procedure. The CA's
function binds the EK to the variable \verb|k0| and the EK certificate
to the message \verb|Cert k0 id0 k_ca'|.  Successful execution of this
command directly implies that the EK certificate is valid.

%% Figure is not referenced in the paper, thus pulling it to get back
%% a page
% \begin{figure}[hbtp]
% \begin{lstlisting}[language=Coq]
% Definition steps_CA (msg : message) (ident : identifier) (ek iak : pubKey) (cert : signedCert) : Prop :=
%   match msg with
%   | (pair (TCG_CSR_IDevID (Device_info id) (Cert k0 id0 k_ca') k) (signature m k')) =>
%         ident = (Device_info id) /\ ek = k0 /\ iak = k /\ cert = (Cert k0 id0 k_ca') /\
%         seq_execute   (iniTPM_CA, inferFrom msg ++ ini_CA)
%                       (CheckHash 
%                           msg 
%                          (TCG_CSR_IDevID (Device_info id) (Cert k0 id0 k_ca') k) ;;
%                        CheckSig 
%                          (signature m k') 
%                           k ;;
%                        CheckCert 
%                          (Cert k0 id0 k_ca') 
%                           pubTM ;;
%                        CheckAttributes 
%                           k 
%                           Restricting Signing NonDecrypting Fixing ;;
%                        TPM2_Hash 
%                          (publicKey k);;
%                        TPM2_MakeCredential 
%                          (hash (publicKey k))
%                           nonce
%                           k0 ;;
%                        Done)
%                       (hash (publicKey k) ::iniTPM_CA, 
%                        encryptedCredential (hash (publicKey k)) nonce k0 :: hash (publicKey k) 
%                        ::inferFrom msg ++ ini_CA)
%   | _ => False
%   end.

% Definition step7_OEM (msg : message) : sequence :=
% TPM2_ActivateCredential 
%     msg 
%     privEK 
%     privIAK ;;
% Done.
% \end{lstlisting}
% \caption{Partial Model of IAK Provisioning Procedure}
% \label{fig:iak_model}
% \end{figure}

We now verify Assurance B when the OEM and the CA are both trusted to
execute their steps correctly. We implement the same strategy as
before showing that the private IAK and private EK are contained in
the OEM's minimal initial \verb|tpm_state|. We build a minimal initial
state pair for the composition of \verb|steps1to4_OEM| and
\verb|step7_OEM| assuming: (i) the EK certificate and public IAK are
known to the Owner because they are included in the CSR and (ii) the
private IAK and private EK are loaded on the same TPM because the IAK
is credentialed by the EK. The two required proofs to determine
minimality proceed similarly to the corresponding proof in the
previous section.

We now attempt formal verification of this same goal when only the CA
is trusted to execute its steps correctly.  We describe the OEM and its
characteristics as a series of assumptions: the OEM executes some
unknown sequence of commands \verb|s1|, this sequence produces some
message \verb|msg| in the OEM's intermediate \verb|state|, the OEM's
initial \verb|tpm_state| may only contain private keys, the OEM's
initial \verb|state| may only contain public keys and certificates,
the CA executes its prescribed sequence on the message \verb|msg| and
sends the challenge blob
\verb|encryptedCredential (hash (publicKey iak)) g ek| to the OEM, the
OEM executes some unknown sequence of commands \verb|s2|, this
sequence releases the secret nonce value \verb|g| into the OEM's next
\verb|state|. The CA's final steps are implicit in the fact that the
nonce in the challenge blob is the same as the nonce in the OEM's next
\verb|state|.  To complete this proof, no further knowledge of the OEM's initial
sequence \verb|s1| is needed.  

\begin{figure}[hptb]
\begin{lstlisting}[language=Coq]
Theorem iak_and_ek_in_TPM :
  forall s2 s1 iniTPM ini midTPM mid finTPM fin msg ident ek iak cert g,
seq_execute (iniTPM, ini) s1 (midTPM, mid) -> 
In msg mid ->
(forall m', needsGeneratedTPM m' -> ~ In m' iniTPM) ->
(forall m', needsGenerated m' -> ~ In m' ini) ->
steps_CA msg ident ek iak cert ->
seq_execute
  (midTPM, inferFrom (encryptedCredential (hash (publicKey iak)) g ek) ++ mid)
  s2 
  (finTPM, fin) ->
In (randomNum g) fin ->
In (privateKey (pubToPrivKey iak)) iniTPM
  /\ In (privateKey (pubToPrivKey ek)) iniTPM.
\end{lstlisting}
\caption{Final Verification Goal for IAK Provisioning Procedure}
\label{fig:iak_goal}
\end{figure}



The OEM's final sequence \verb|s2| must now be analyzed.  We prove
that \verb|s2| is a supersequence of the correct next steps of the OEM
(i.e., \verb|step7_OEM|). This proof relies on two important
properties of sequential execution. The first being that one cannot
produce a random number in its final \verb|state| without an encrypted
credential containing that number in its initial \verb|state|. The
next property states approximately the converse of the first, one
cannot produce an encrypted credential containing a particular random
number in its final \verb|state| without that number or an encrypted
credential containing that number in its initial \verb|state|.

Our next step is to demonstrate that the OEM must in fact have
executed \verb|TPM2_ActivateCredential| on the challenge blob using
the private EK and private IAK. This result is a direct consequence of
the supersequence conclusion. We then verify that execution of a
sequence containing this command implies that the EK and IAK are
loaded on the same TPM.  The composition of these small proofs leads
to our goal shown in Figure \ref{fig:iak_goal}.  Due to the extra
parameters and criteria of the \verb|steps_CA| function, the proof
statement shows that the inverse of the key contained in the EK
certificate and the inverse of the key contained in the new
certificate are loaded on the same TPM. This is precisely the
assertion described by Assurance B.

In conclusion, we us the previously-certified EK to prove that the new
IAK is loaded on the same TPM as itself. When issuing the IAK
certificate, the CA uses the device identifying information from the
recieved CSR.  Assurance A is guaranteed by the attribute check
performed by the CA, Assurance B is guaranteed by the EK's
\verb|Restricted| attribute and the secret contained in the challenge
blob, and Assurance C is guaranteed by the signature check on the EK
certificate performed by the CA.

Our analysis has revealed a potential shortcoming in the IAK
provisioning procedure. The procedure provides no assurance regarding
IAK device-residency.  The IAK certificate is intended to provide
evidence that a key belongs to a specific device, yet the procedure
makes no guarantees that the IAK is actually on the device.  Proving
an IAK belongs to a specific device requires first binding the IAK to
a specific TPM using the EK and then binding the TPM to a specific
device \citep{DevIDSpec-TCG}.  However, the CA makes no attempt at
performing the second part of this process. Instead the CA fully
trusts the OEM to have provided the correct device identifying
information.

Even the attestation variation of the IAK provisioning procedure does
not attempt verification. This variation uses a quote over selected
PCRs to show only that the device is running the appropriate, trusted
firmware. All devices with the same model number have an identical
golden hash value that represents its expected PCR digest.  Although
this check guarantees that the TPM containing the IAK is on a specific
\textit{type} of device it does not guarantee that the TPM is on a
specific device.

A small change to the attestation variation of the IAK provisioning
procedure can overcome this shortcoming. The TPM should take a
measurement that contains the device's serial number. In this way,
each individual device has a unique golden hash value, and thus its
identity can be uniquely determined.  Due to the measurement integrity
guaranteed by the TPM's PCR mechanism, this modification provides
definitive evidence that a key belongs to a specific device, the exact
result which an IAK certificate is intended to have. A downfall of
this solution is that it requires a large database of golden hash
values. Therefore, it may be unrealistic and even unnecessary to
implement this change in circumstances where a precise device identity
is not required. However, this solution may still be useful in
critical systems where it is imperative to know the identity of a
specific device.
%
%
%
\section{Conclusions and Future Work}

The major contributions of the research presented here may be
summarized as: (i) a general investigation into TPM-based DevIDs and
chains of certificates; (ii) the design and implementation of an
abstract formal model of command execution; (iii) an in-depth analysis
of two TCG-provided key certification protocols, and (iv) the
discovery of a potential shortcoming of the IAK provisioning procedure
and a recommendation for its improvement.

Although the modeled command library and execution environment are
useful in verifying properties over some key certification protocols,
further improvements are necessary to extend the applicability of this
model to a broader range of problems. An initial step towards
achieving this is to expand the command library to include the TPM
commands necessary for modeling the attestation variation of these
provisioning protocols. These attestation variations use PRCs to
inform a remote CA of the internal state of a certificate-requesting
entity. This variation is strongly encouraged to be performed during
certification of an IAK so that the CA may be assured it is issuing a
certificate to a device running trusted software.

To include PCR-related commands, the structure of abstract state
should be modified from a pair to a record similar to that of the work
of \citet{PrivacyCAAnalysis-Hall}. These advancements to the model
also provide the mechanisms necessary to verify recommended changes to
the IAK provisioning procedure.

In addition to adding PCR-related commands, it is useful to include
more TPM and TSS commands in general. By expanding the range of
commands supported by this model, we can describe a broad range of
situations beyond DevID provisioning protocols.
Besides expanding the modeled TPM command library, we may also improve
on the execution environment. Specifically, more complex control
sequences such as branching and looping should be included so that we
can describe more elaborate scenarios.
%
%
%
\begin{comment}
\section{First Section}
\subsection{A Subsection Sample}
Please note that the first paragraph of a section or subsection is
not indented. The first paragraph that follows a table, figure,
equation etc. does not need an indent, either.

Subsequent paragraphs, however, are indented.

\subsubsection{Sample Heading (Third Level)} Only two levels of
headings should be numbered. Lower level headings remain unnumbered;
they are formatted as run-in headings.

\paragraph{Sample Heading (Fourth Level)}
The contribution should contain no more than four levels of
headings. Table~\ref{tab1} gives a summary of all heading levels.

\begin{table}
\caption{Table captions should be placed above the
tables.}\label{tab1}
\begin{tabular}{|l|l|l|}
\hline
Heading level &  Example & Font size and style\\
\hline
Title (centered) &  {\Large\bfseries Lecture Notes} & 14 point, bold\\
1st-level heading &  {\large\bfseries 1 Introduction} & 12 point, bold\\
2nd-level heading & {\bfseries 2.1 Printing Area} & 10 point, bold\\
3rd-level heading & {\bfseries Run-in Heading in Bold.} Text follows & 10 point, bold\\
4th-level heading & {\itshape Lowest Level Heading.} Text follows & 10 point, italic\\
\hline
\end{tabular}
\end{table}


\noindent Displayed equations are centered and set on a separate
line.
\begin{equation}
x + y = z
\end{equation}
% Please try to avoid rasterized images for line-art diagrams and
% schemas. Whenever possible, use vector graphics instead (see
% Fig.~\ref{fig1}).

% \begin{figure}
% \includegraphics[width=\textwidth]{fig1.eps}
% \caption{A figure caption is always placed below the illustration.
% Please note that short captions are centered, while long ones are
% justified by the macro package automatically.} \label{fig1}
% \end{figure}

\begin{theorem}
This is a sample theorem. The run-in heading is set in bold, while
the following text appears in italics. Definitions, lemmas,
propositions, and corollaries are styled the same way.
\end{theorem}
%
% the environments 'definition', 'lemma', 'proposition', 'corollary',
% 'remark', and 'example' are defined in the LLNCS documentclass as well.
%
\begin{proof}
Proofs, examples, and remarks have the initial word in italics,
while the following text appears in normal font.
\end{proof}

We can use \verb+citep+ for authors names like~\citep{Petz:2019aa} or
\verb+citet+ for the traditional numerical
citation~\citet{Ramsdell:2019aa}.

When submitting papers that must conform to LNCS standards just use
\verb+cite+ for citations like~\citep{Petz:2019aa} and comment out the
\verb+natbib+ include above and swap \verb+bibliographystyle+ commands
below.
\end{comment}
% 
% 
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
%\bibliographystyle{splncs04}
\bibliographystyle{splncsnat}
%\bibliography{sldg}
\bibliography{bib/sldg,bib/thesis_bibliography}
%
\end{document}
